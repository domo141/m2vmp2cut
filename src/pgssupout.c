#if 0 /* -*- mode: c; c-file-style: "stroustrup"; tab-width: 8; -*-
 set -eu; case $1 in -o) trg=$2; shift 2
	;;	*) trg=`exec basename "$0" .c` ;; esac; rm -f "$trg"
 WARN="-Wall -Wno-long-long -Wstrict-prototypes -pedantic"
 WARN="$WARN -Wcast-align -Wpointer-arith " # -Wfloat-equal #-Werror
 WARN="$WARN -W -Wwrite-strings -Wcast-qual -Wshadow" # -Wconversion
 case ${1-} in '') set x -O2; shift; esac
 #case ${1-} in '') set x -ggdb; shift; esac
 set -x; exec ${CC:-gcc} -std=c99 $WARN "$@" -o "$trg" "$0"
 exit $?
 */
#endif
/*
 * $ pgssupout.c $
 *
 * Author: Tomi Ollila -- too Ã¤t iki piste fi
 *
 *	Copyright (c) 2012 Tomi Ollila
 *	    All rights reserved
 *
 * Created: Sun 28 Oct 2012 09:58:21 EET too
 * Last modified: Sat 14 Feb 2015 23:03:36 +0200 too
 */

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>
#include <string.h>
#include <errno.h>

#include <sys/stat.h>
#include <fcntl.h>

#define null ((void*)0)

// (variable) block begin/end -- explicit liveness...
#define BB {
#define BE }

#define DBG 0

#define d0(format, ...) do {} while (0)
#if DBG
void d1(const char * format, ...)
{
    va_list ap; va_start(ap, format); vfprintf(stderr, format, ap); va_end(ap);
}
#else
#define d1(format, ...) do {} while (0)
#endif

/* This program writes PGS subtitles e.g. for mkv inclusion */

// Peeked BDSup2Sub/src/main/java/bdsup2sub/supstream/bd/SupBD.java
// and pgssubdec.c in ffmpeg sources.
// using my readpgs.py for doing header testing.

enum { PGS = 0x16, WINDOW = 0x17, PALETTE = 0x14, PICTURE = 0x15,
       DISPLAY = 0x80 };

// to show subtitle, have 16, 17, 14, 15, 80 -- to hide 16, 17, 80

/* Example (.sup generated by BDSup2Sub 4.0.1, examined by my readpgs.py):

pts 00:01:14.76, dts 00:01:14.75, st 16 (present), sl 19
  width: 720, height: 576, frame rate code: 48
  composition number: 0, composition state: 128
  palette update flag: 0, palette id ref: 0
  number of composition objects: 1
    id ref: 0, win ref: 0, flag: 0 x: 89, y: 500

pts 00:01:14.76, dts 00:01:14.75, st 17 (window ), sl 10
  number of windows: 1, window id: 0
  x: 89, y: 500, width: 104, height: 31

pts 00:01:14.75, dts 00:00:00.00, st 14 (palette), sl 52
  id: 0, y:  16, cr: 128, cb: 128, alpha: 0
  id: 1, y:  54, cr: 128, cb: 128, alpha: 255
  id: 2, y:  53, cr: 128, cb: 128, alpha: 255
  id: 3, y:  86, cr: 128, cb: 128, alpha: 255
  id: 4, y: 195, cr: 128, cb: 128, alpha: 255
  id: 5, y: 122, cr: 128, cb: 128, alpha: 255
  id: 6, y: 218, cr: 128, cb: 128, alpha: 255
  id: 7, y: 140, cr: 128, cb: 128, alpha: 255
  id: 8, y: 167, cr: 128, cb: 128, alpha: 255
  id: 9, y:  98, cr: 128, cb: 128, alpha: 255

pts 00:01:14.75, dts 00:01:14.75, st 15 (picture), sl 2233
  object id: 0, version: 0, sequence description: 0xc0
  bitmap length: 2222, width: 104, height: 31

pts 00:01:14.75, dts 00:00:00.00, st 80 (display), sl 0

-----

pts 00:01:17.40, dts 00:01:14.76, st 16 (present), sl 11
  width: 720, height: 576, frame rate code: 48
  composition number: 1, composition state: 0
  palette update flag: 0, palette id ref: 0
  number of composition objects: 0

pts 00:01:17.40, dts 00:01:14.76, st 17 (window ), sl 10
  number of windows: 1, window id: 0
  x: 89, y: 500, width: 104, height: 31

pts 00:01:14.76, dts 00:00:00.00, st 80 (display), sl 0

 */

// These could be typedefs -- now gcc -E shows "expanded" types.
#define uf32_t uint_fast32_t
#define uf16_t uint_fast16_t
#define uf8_t uint_fast8_t

//void die(const char * format, ...) GCCATTR_NORETURN;
void die(const char * format, ...)
{
    int err = errno;
    va_list ap;

    va_start(ap, format);
    vfprintf(stderr, format, ap);
    va_end(ap);

    if (format[strlen(format) - 1] == ':')
	fprintf(stderr, " %s.\n", strerror(err));
    else
	fprintf(stderr, "\n");
    exit(1);
}

void xreadfully(int fd, unsigned char * buf, ssize_t len)
{
    int tl = 0;

    if (len <= 0)
	return;

    while (true)
    {
	int l = read(fd, buf, len);

	if (l == len)
	    return;

	if (l <= 0)
	{
	    if (errno == EINTR)
		continue;
	    else
		die("read() failed:");
	}
	tl += l;
	buf += l;
	len -= l;
    }
}

struct {
    uint8_t buf[65536];
    uint8_t * ptr;
    uint8_t * out;
} WB;

void wbuf_init(void)
{
    WB.ptr = WB.buf;
    // useless micro-optimization just for fun.
    WB.ptr[0] = 'P'; WB.ptr[1] = 'G';
    WB.out = WB.buf + sizeof WB.buf;
}

void wbuf_flush(void)
{
    ssize_t len = WB.ptr - WB.buf;
    const uint8_t * buf = WB.buf;

    if (len <= 0)
	return;

    while (true)
    {
	int l = write(1, buf, len);

	if (l == len) {
	    WB.ptr = WB.buf;
	    return;
	}
	if (l <= 0)
	{
	    if (errno == EINTR)
		continue;
	    else
		die("write failed:");
	}
	buf += l;
	len -= l;
    }
}

uint8_t * wbuf_get(int size)
{
    if (WB.ptr + size >= WB.out)
	wbuf_flush();
    else {
	WB.ptr[0] = 'P'; WB.ptr[1] = 'G';
    }
    uint8_t * rv = WB.ptr;
    WB.ptr += size;
    return rv;
}


/* */

typedef struct
{
    uint8_t * bmpbuf;
    int bmpbufsize;
    int width;
    int height;
    uint8_t * image;
    uint8_t ycrcb[256][3];
    uint8_t cmap[256];
    int colors;
} Bmp;

bool bmp_init(Bmp * bmp);
bool bmp_load(Bmp * bmp, const char * filename);
int bmprlesize(Bmp * bmp);
int bmp2rle(Bmp * bmp, uint8_t * buf);


/* */

// to avoid alignment problems
void _a32be(uint8_t * d, uf32_t val)
{
    d[0] = val >> 24; d[1] = val >> 16; d[2] = val >> 8; d[3] = val;
}
void _a16be(uint8_t * d, uf32_t val)
{
    d[0] = val >> 8; d[1] = val;
}

uint8_t * inserthdr(uf32_t pts, uf32_t dts, uf8_t segtype, uf16_t seglen)
{
    uint8_t * buf = wbuf_get(13 + seglen);
    _a32be(buf + 2, pts);
    _a32be(buf + 6, dts);
    buf[10] = segtype;
    _a16be(buf + 11, seglen);
    return buf;
}

void writepgs(uf32_t pts, uf32_t dts, uf16_t width, uf16_t height,
	      int cs, int nco, uf16_t x, uf16_t y)
{
    static uf16_t composition_number = 0;
    int seglen = nco? 19: 11;
    uint8_t * buf = inserthdr(pts, dts, PGS, seglen);

    _a16be(buf + 13, width);
    _a16be(buf + 15, height);
    buf[17] = 0x30; // 3: frame rate high nibble (ignored by readers).
    _a16be(buf + 18, composition_number++);
    buf[20] = cs;
    buf[21] = 0x00; // palette update flag -- SupBD.java...
    buf[22] = 0x00; // palette id ref, zero always.
    buf[23] = nco; // number of composition objects.
    if (nco) {
	_a16be(buf + 24, 0); // object id ref;
	buf[26] = 0x00; // window id ref
	buf[27] = 0x00; // composition flag (0x80 - cropped, 0x40 - forced)
	_a16be(buf + 28, x);
	_a16be(buf + 30, y);
    }
}

void writewindow(uf32_t pts, uf32_t dts, uf16_t width, uf16_t height,
		 uf16_t x, uf16_t y)
{
    uint8_t * buf = inserthdr(pts, dts, WINDOW, 10);
    buf[13] = 0x01; // number of windows
    buf[14] = 0x00; // window id
    _a16be(buf + 15, x);
    _a16be(buf + 17, y);
    _a16be(buf + 19, width);
    _a16be(buf + 21, height);
}

void writepalette(uf32_t pts, uf32_t dts, Bmp * bmp)
{
    int seglen = 2 + bmp->colors * 5;
    uint8_t * buf = inserthdr(pts, dts, PALETTE, seglen);

    buf[13] = 0; // null byte
    buf[14] = 0; // null byte
    uint8_t *p = buf + 15;
    for (int i = 0; i < bmp->colors; i++) {
	p[0] = i; p[1] = bmp->ycrcb[i][0]; p[2] = bmp->ycrcb[i][1];
	p[3] = bmp->ycrcb[i][2]; p[4] = 255;
	p += 5;
    }
    buf[19] = 0; // color 0 alpha 0
}

void writepicture(uf32_t pts, uf32_t dts, int width, int height, Bmp * bmp)
{
    int rlelen = bmprlesize(bmp);
    if (rlelen > 65500)
	die("Rle-encoded image takes too much space");
    int seglen = 11 + rlelen;

    uint8_t * buf = inserthdr(pts, dts, PICTURE, seglen);

    _a16be(buf + 13, 0); // object id
    buf[15] = 0; // version
    buf[16] = 0xc0; // sequence description -- no append
    // 24 bits of length... rle len + 4 (x & y info)
    int len = rlelen + 4;
    buf[17] = len >> 16; // well, 0 always -- as we don't support longer...
    _a16be(buf + 18, len & 0xffff); // 16 lowest bits of len (obvious :)
    _a16be(buf + 20, width);
    _a16be(buf + 22, height);

    (void)bmp2rle(bmp, buf + 24);
}

void writedisplay(uf32_t pts, uf32_t dts)
{
    inserthdr(pts, dts, DISPLAY, 0);
}

uf32_t tc2pts(char * tc)
{
    int h, m;
    float sms;
    if (sscanf(tc, "%d:%d:%f", &h, &m, &sms) != 3)
	die ("Timecode '%s' format error", tc);
    return h * 3600 * 90000 + m * 60 * 90000 + (int)(sms * 90000.0);
}

int main(int argc, char * argv[])
{
    if (argc != 6)
	die("\nUsage: %s vwidth vheight datafile file_fmt_str outfile\n\n" \
	    "datafile line format:\n      image='%%d' start='hh:mm:ss.mmm' " \
	    "end='hh:mm:ss.mmm' x='%%d' y='%%d'\n", argv[0]);
#if 0
    BB;
    struct stat st;
    if (stat(argv[5], &st) == 0)
	die("Output file '%s' exists\n", argv[5]);
    BE;
#endif
    int v_width = atoi(argv[1]);
    int v_height = atoi(argv[2]);

    wbuf_init();
    Bmp bmp;
    (void)bmp_init(&bmp);

    FILE * datafile = fopen(argv[3], "r");
    if (datafile == null)
	die("Opening '%s' failed:", argv[3]);

    BB;
    int fd = open(argv[5], O_WRONLY|O_CREAT|O_TRUNC, 0644);
    if (fd < 0)
	die("Opening '%s' for writing failed:", argv[5]);
    dup2(fd, 1);
    close(fd);
    BE;

    char buf[128];
    int ln = 0;
    while (fgets(buf, sizeof buf, datafile) != null) {
	ln++;
	if (memcmp(buf, "image=", 6) != 0) {
	    if (buf[0] != '#')
		die("%s:%d: unknown content: '%s'", argv[3], ln, buf);
	    continue;
	}

	int num; char start[16]; char end[16]; int x; int y;
	if (sscanf(buf, "image='%d' start='%15[0-9:.]' end='%15[0-9:.]' x='%d' y='%d'",
		   &num, start, end, &x, &y) != 5)
	    die("%s:%d: line format error: '%s'", argv[3], ln, buf);

	// start & end check. function to parse...

	char filename[256]; // XXX
	snprintf(filename, sizeof filename, argv[4], num);

	(void)bmp_load(&bmp, filename);

	int width = bmp.width;
	int height = bmp.height;

	// All these calculations modeled from SupBD.java 2012-10-29 ....
	// The dts == 0 setting in f108de55fba3d700dc63af6fa8bb505a7b0b17a9
	// not used yet (but dts setting may not be in pre f108d.. state).
	int frameinittime = (v_width * v_height * 9 + 3199) / 3200;
	int windowinittime = frameinittime;
	int imagedecodetime = (width * height * 9 + 1599) / 1600;

	int spts = tc2pts(start);
	int epts = tc2pts(end);

	int pts, dts, ts;
	// XXX
	dts = spts - (frameinittime + windowinittime); // XXX
	writepgs(spts, dts, v_width, v_height, 0x80, 1, x, y);
	ts = pts = spts - windowinittime; // XXX
	writewindow(pts, dts, width, height, x, y);
	writepalette(dts, dts, &bmp); // pts is previous dts (or vice versa)
	pts = dts + imagedecodetime; // XXX
	writepicture(pts, dts, width, height, &bmp);
	writedisplay(ts, dts);
	// and the XXX's for timing continue (where is specs!!!)
	writepgs(epts, spts, v_width, v_height, 0, 0, 0, 0);
	pts = epts - windowinittime; // XXX
	writewindow(pts, spts, width, height, x, y);
	writedisplay(pts, spts);
    }

    wbuf_flush();
    return 0;
}

static void rgb2yuv(uint8_t r,   uint8_t    g, uint8_t   b,
                    uint8_t * y, uint8_t * cr, uint8_t * cb)
{
    /* from dvdauthor... */
    *y  = ( 257 * r + 504 * g +  98 * b +  16500) / 1000;
    *cr = ( 439 * r - 368 * g -  71 * b + 128500) / 1000;
    *cb = (-148 * r - 291 * g + 439 * b + 128500) / 1000;
}

bool bmp_init(Bmp * bmp)
{
    bmp->bmpbuf = (uint8_t *)malloc(65536);
    if (bmp->bmpbuf == null)
	die("Out of memory!");

    bmp->bmpbufsize = 65536;

    // ProjectX-generated bmp has background (alpha0) as color #000060
    // making sure that color hits as index 0
    rgb2yuv(0, 0, 96, &bmp->ycrcb[0][0], &bmp->ycrcb[0][1], &bmp->ycrcb[0][2]);
    // bmp->colors = 1; initialized in load.

    return true;
}

#define _g32le(p) ((p)[0] + ((p)[1]<<8) + ((p)[2]<<16) + ((p)[3]<<24))
#define _g16le(p) ((p)[0] + ((p)[1]<<8))

bool bmp_load(Bmp * bmp, const char * filename)
{
    // maybe move all of these to bmp...
    int fd = open(filename, O_RDONLY);
    if (fd < 0)
	die("Opening '%s' failed:", filename);

    struct stat st;
    if (fstat(fd, &st) < 0)
	die("fstat failed:");
    if (st.st_size > bmp->bmpbufsize) {
	bmp->bmpbuf = (uint8_t *)realloc(bmp->bmpbuf, st.st_size);
	if (bmp->bmpbuf == null)
	    die("Out of memory!");
	bmp->bmpbufsize = st.st_size;
    }
    // ease of use
    uint8_t * buf = bmp->bmpbuf;

    xreadfully(fd, buf, st.st_size);
    close(fd);
    // http://en.wikipedia.org/wiki/BMP_file_format

    if (buf[0] != 'B' || buf[1] != 'M')
	die("Header signature '%c%c' not 'BM'", buf[0], buf[1]);

    //int size = _g32le(buf + 2);
    int offset = _g16le(buf + 0x0a);

    int hdrsize = _g32le(buf + 0x0e);
    int width = _g32le(buf + 0x12);
    int height = _g32le(buf + 0x16);
    int bpp = _g16le(buf + 0x1c);
    int cm = _g32le(buf + 0x1e);
    //int isize = _g32le(buf + 0x22);
    int cn = _g32le(buf + 0x2e);

    if (hdrsize != 40)
	die("Tested only on 40 byte header");
    if (bpp != 8)
	die("Only 8 bits per pixel bmp images supported ATM");
    if (cm != 0)
	die("Unsupported compression method %d "
	    "(not 0 == BI_RGB (uncompressed))", cm);

    int adv = (width + 3) & ~3;
    if (adv * height > bmp->bmpbufsize - offset)
	die("%s: image size byte requirement exceeds loaded file size",
	    filename);

    bmp->width = width;
    bmp->height = height;

    if (cn == 0)
	cn = 1 << bpp;

    // Quantize...
    // map of used color indexes. !! 8bpp !!
    uint8_t cim[256] = { 0 };
    uint8_t * image = buf + offset;
    bmp->image = image;
    for (int i = 0; i < height; i++)
	for (int j = 0; j < width; j++) {
	    uint8_t ci = image[j + adv * i];
	    cim[ci] = 1;
	}

    // color table after DIB in case cm not BI_BITFIELDS

    bmp->colors = 1; // keep the first (transparent) there (in index 0)
    uint8_t * p = buf + 14 + hdrsize;
    for (int i = 0; i < cn; i++, p += 4) {
	if (cim[i] == 0)
	    // this color index not used.
	    continue;
	uint8_t y, cr, cb, j;
	// "In most cases, each entry in the color table occupies 4 bytes, in
	// the order blue, green, red, 0x00" (wikipedia: BMP_file_format).
	rgb2yuv(p[2], p[1], p[0], &y, &cr, &cb);
	for (j = 0; j < bmp->colors; j++)
	    if (y == bmp->ycrcb[j][0]
		&& cr == bmp->ycrcb[j][1] && cb == bmp->ycrcb[j][2]) {
		break;
	    }
	bmp->cmap[i] = j;
	if (j == bmp->colors) {
	    bmp->ycrcb[j][0] = y;
	    bmp->ycrcb[j][1] = cr;
	    bmp->ycrcb[j][2] = cb;
	    bmp->colors++;
	}
	d0("%2d %2d: %3d %3d %3d  %3d %3d %3d\n", i,j,p[2],p[1],p[0],y,cr,cb);
    }

//    die("size %d, offset %d hdrsize %d, width %d, height %d, bpp = %d, "
//	"cm %d, isize %d, cn %d\n",
//	size, offset, hdrsize, width, height, bpp, cm, isize, cn);

    return true;
}

int bmprlesize(Bmp * bmp)
{
    int width = bmp->width;
    int height = bmp->height;
    int adjwidth = (width + 3) & ~3;
    int len;
    int rv = 0;
    uint8_t color;
    uint8_t * image = bmp->image;
    uint8_t * cmap = bmp->cmap;

    // pretty straight conversion from SupBD.java in BDSup2Sub.
    for (int y = height - 1; y >= 0; y--) {
	int ofs = y * adjwidth;
	int x;
	for (x = 0; x < width; x += len, ofs += len) {
	    color = cmap[image[ofs]];
	    for (len = 1; x + len < width; len++) {
		if (cmap[image[ofs+len]] != color)
		    break;
	    }
	    if (len <= 2 && color != 0)
		rv += len;
	    else {
		if (len > 0x3fff)
		    len = 0x3fff;
		rv++;
		// commented out due to bug in SupRip
		/*if (color == 0 && x+len == bm.getWidth()) {
		    bytes.add((byte)0);
		    eol = true;
		} else*/
		if (color == 0 && len < 0x40) {
		    // 00 xx -> xx times 0
		    rv++;
		} else if (color == 0) {
		    // 00 4x xx -> xxx zeroes
		    rv += 2;
		} else if (len < 0x40) {
		    // 00 8x cc -> x times value cc
		    rv += 2;
		} else {
		    // 00 cx yy cc -> xyy times value cc
		    rv += 3;
		}
	    }
	}
	if (/*!eol &&*/ x == width) {
	    rv += 2;
	}
    }
    return rv;
}


// Convert bitmap to run-length-encoded format, rtfs spec.
// Transparent pixels around the picture could be cropped but that
// would lose information (someone may want to add some alpha later).
int bmp2rle(Bmp * bmp, uint8_t * buf)
{
    uint8_t *p = buf;
    int width = bmp->width;
    int height = bmp->height;
    int adjwidth = (width + 3) & ~3;
    int len;
    uint8_t color;
    uint8_t * image = bmp->image;
    uint8_t * cmap = bmp->cmap;
    // pretty straight conversion from SupBD.java in BDSup2Sub.
    for (int y = height - 1; y >= 0; y--) {
	int ofs = y * adjwidth;
	int x;
	for (x = 0; x < width; x += len, ofs += len) {
	    color = cmap[image[ofs]];
	    for (len = 1; x + len < width; len++) {
		if (cmap[image[ofs+len]] != color)
		    break;
	    }
	    if (len <= 2 && color != 0) {
		// only a single occurrence -> add color
		*p++ = color;
		if (len == 2)
		    *p++ = color;
	    }
	    else {
		if (len > 0x3fff)
		    len = 0x3fff;
		*p++ = '\0';  // rle id
		// commented out due to bug in SupRip
		/*if (color == 0 && x+len == bm.getWidth()) {
		    bytes.add((byte)0);
		    eol = true;
		} else*/
		if (color == 0 && len < 0x40) {
		    // 00 xx -> xx times 0
		    *p++ = (uint8_t)len;
		} else if (color == 0) {
		    // 00 4x xx -> xxx zeroes
		    *p++ = (uint8_t)(0x40|(len>>8));
		    *p++ = (uint8_t)len;
		} else if (len < 0x40) {
		    // 00 8x cc -> x times value cc
		    *p++ = (uint8_t)(0x80|len);
		    *p++ = color;
		} else {
		    // 00 cx yy cc -> xyy times value cc
		    *p++ = (uint8_t)(0xc0|(len>>8));
		    *p++ = (uint8_t)len;
		    *p++ = color;

		}
	    }
	}
	if (/*!eol &&*/ x == width) {
	    *p++ = '\0';  // rle id
	    *p++ = '\0';
	}
    }
    return p - buf;
}
